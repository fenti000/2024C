# 建模思路（OR/优化视角）

## 1. 目标与范围

* **规划期**：2024–2030 共 7 年。
* **决策粒度**：按“地块 × 年 × 季次（第一季/第二季/单季）”，每个季次至多选择一种作物（不做同一季的混合作物/分割面积）。
* **目标函数**：在给定规则和需求量条件下，**最大化总净收益**（各地块各季次收益之和）。

## 2. 数据与参数

* 地块信息（类型、面积）
* 作物信息（名称、类型）
* 2023 年历史种植记录（轮作约束的参照）
* 经济数据（亩产量、种植成本、销售单价区间→取均价、由此得到“每亩净收益”）
* 预期销售量（来自 ExpectedSales.xlsx）

## 3. 关键约束

* **轮作约束（豆类）**：每块地**近三年内至少一次豆类**。实现方式：若去年与前年都未种豆，今年必须选豆类（若有可行项）。
* **同作物连作限制**：不允许“今年”种与“去年”同名作物（排除去年的作物）。
* **地块-作物-季次匹配规则**（以逻辑编码实现）：

  * 平旱地 / 梯田 / 山坡地：**单季**粮食。
  * 水浇地：比较两方案
    A）**单季水稻** vs B）**两季蔬菜**（第一季常规蔬菜、第二季限定“大白菜/白萝卜/红萝卜”）。
  * 普通大棚：**第一季蔬菜** + **第二季食用菌**。
  * 智慧大棚：**第一季蔬菜** + **第二季蔬菜**。

## 4. 收益计算（分情景）

令

* $Y$：亩产量（斤/亩）
* $P$：平均单价（元/斤）
* $C$：亩成本（元/亩）
* $D$：**（假设为“每亩可消化需求”）**
* $A$：地块面积（亩）

分两种情景：

1. **滞销浪费（waste）**

$$
\text{亩收益}=
\begin{cases}
Y\cdot P - C, & Y \le D\\
D\cdot P - C, & Y > D
\end{cases}
$$

总收益 = 亩收益 × $A$。

2. **滞销降价 50%（discount）**

$$
\text{亩收益}=
\begin{cases}
Y\cdot P - C, & Y \le D\\
D\cdot P + (Y-D)\cdot (0.5P) - C, & Y > D
\end{cases}
$$

总收益 = 亩收益 × $A$。

> **重要假设**：上述 $D$ 在代码实现中与 $Y$（亩产）直接比较，随后再整体乘以面积 $A$，这等价于把需求量理解为“**每亩需求**”。若 Excel 中的需求是**全局总需求**，则属于一种简化假设（非总量联动）。

## 5. 决策机制（贪心/逐地块逐年）

* 对每个“地块-年份”，根据地块类型与约束，列出**可行候选**（满足季次、轮作、连作限制）。
* 按“**每亩净收益**”或两季收益之和排序，结合需求情景计算**实际净收益**，选取最优组合。
* 决策完毕后，更新**历史记录**（用于下一年轮作与连作限制）。

## 6. 输出与评价指标

* **逐年**输出“地块 × （作物-季次）面积矩阵”CSV（列名形如 `作物-第一季`、`作物-第二季`；其中 `单季` 统一归为 `第一季` 展示）。
* 控制台输出两种情景的**年均净收益**（不再写入 CSV）。

---

# 编程实现思路（代码结构视角）

## A. 数据加载与预处理 `load_data()`

* 读取 5 份数据（UTF-8 / GBK 兼容）。
* 标准化列名；对经济数据**拆区间价**取均价，得到 `平均单价` 与 `每亩净收益`。
* 构建 `CROP_DEMANDS`：

  * 从 ExpectedSales.xlsx 中识别（`预期销售量/斤` / `预期销售量` / `销售量`）列。
  * **若文件结构不符合预期：抛出错误，中断运行**（不再走默认总表）。
  * 若某**单个作物**未出现在表中：该作物在收益计算时用 `1000` 作为**缺省每亩需求**。

## B. 规则与集合

* `BEAN_CROPS`（豆类）、`SEASON2_VEG`（第二季限定蔬菜）、`FUNGI_CROPS`（食用菌）。
* `PLANT_RULES` 字典定义了匹配规则（当前核心逻辑主要体现在后续各 handler 中）。

## C. 核心决策函数

1. `find_best_planting(plot_name, year, history, economic_data, land_info, scenario)`

   * 取地块类型、面积；读取上一年&上上年的作物清单，判断是否“**本年需豆**”。
   * 分派到不同处理器：

     * 单季旱地类 → `_handle_single_season`
     * 水浇地 → `_handle_water_land`
     * 大棚 → `_handle_greenhouse(is_smart=...)`
   * 返回：`{'plan': [若干 {地块, 作物, 面积, 季次}], 'profit': 当年该地块收益}`。

2. `calculate_profit(crop_row, area, scenario, demand)`

   * 按“浪费/降价 50%”两情景，计算**亩收益**后乘以面积。
   * `demand` 来自 `CROP_DEMANDS.get(作物, 1000)`。

3. `_handle_single_season(...)`

   * 候选：匹配“地块类型 & 单季”，排除去年作物；若需豆 → 限定豆类。
   * 取**每亩净收益**最高的作物，结合需求情景算收益，返回单季方案。

4. `_handle_water_land(...)`

   * **方案 A**：单季水稻（若去年没种），算收益。
   * **方案 B**：两季蔬菜（第一季：常规蔬菜；第二季：限定 `SEASON2_VEG`；均排除去年作物；如需豆，第一季再限定豆类），取两季最优组合收益之和。
   * 比较 A/B，返回收益更高的方案。

5. `_handle_greenhouse(..., is_smart)`

   * 第一季候选：蔬菜（普通大棚排除第二季蔬菜清单；如需豆 → 限定豆类）。
   * 第二季候选：

     * 智慧大棚：蔬菜；
     * 普通大棚：**食用菌**。
   * 分别取第一季、第二季的**最佳作物**，合并收益。

> 若某类候选为空 → 返回空方案、0 收益（对水浇地存在一处边界情况：当两方案皆无可行项时需谨慎处理；当前实现用 $-\infty$ 作为备选收益，结果分支可能返回“水稻”但实际不可行，后续可加守卫判定）。

## D. 历史记录与结果矩阵

* `load_2023_data()`：把 2023 年“地块→作物清单”载入 `history[2023]`。
* 每年完成方案后，写入 `history[year][地块] = [该年所有作物名]`，用于下一年约束判断。
* `create_result_template(...)`：

  * 行：地块；列：**作物-第一季 / 作物-第二季**（预先为每个作物建两列）。
  * 写入面积：把 `单季` 归并到 `第一季` 列。

## E. 文件输出与汇总

* `save_results(...)`：按**情景×年份**输出一个 CSV：`result1_{scenario}_{year}.csv`。
* `solve_problem_1_scenario(...)`：循环 2024–2030

  * 逐地块决策、累计收益、打印年度收益、保存年度矩阵。
  * 最后打印 **年均净收益**（**不保存到 CSV**）。
* `main()`：依次跑 `waste` 与 `discount` 两情景，打印两者年均净收益。

---

# 运行流程（总览）

1. `main()` → `load_data()`（读取并校验 ExpectedSales.xlsx）
2. 场景一 `waste`：

   * 年度循环（2024→2030）

     * 地块循环 → `find_best_planting()` → `_handle_*()` → `calculate_profit()`
     * 更新 `history`、保存 `result1_waste_{year}.csv`、打印年度收益
   * 打印“waste 年均净收益”
3. 场景二 `discount`：流程同上
4. 打印两场景**年均净收益**

